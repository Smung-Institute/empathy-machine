{"version":3,"sources":["particles.js"],"names":["Tween","timeArray","valueArray","times","values","Particle","position","THREE","Vector3","velocity","acceleration","angle","angleVelocity","angleAcceleration","size","color","Color","opacity","age","alive","particleVertexShader","join","particleFragmentShader","prototype","lerp","t","i","n","length","p","clone","update","dt","add","multiplyScalar","sizeTween","colorTween","colorHSL","setHSL","x","y","z","opacityTween","Type","Object","freeze","ParticleEngine","positionStyle","CUBE","positionBase","positionSpread","positionRadius","velocityStyle","velocityBase","velocitySpread","speedBase","speedSpread","accelerationBase","accelerationSpread","angleBase","angleSpread","angleVelocityBase","angleVelocitySpread","angleAccelerationBase","angleAccelerationSpread","sizeBase","sizeSpread","colorBase","colorSpread","opacityBase","opacitySpread","blendStyle","NormalBlending","particleArray","particlesPerSecond","particleDeathAge","emitterAge","emitterAlive","emitterDeathAge","particleCount","Math","min","particleGeometry","Geometry","particleTexture","particleMaterial","ShaderMaterial","uniforms","texture","type","value","attributes","customVisible","customAngle","customSize","customColor","customOpacity","vertexShader","fragmentShader","transparent","blending","depthTest","particleMesh","Mesh","setValues","parameters","undefined","key","alphaTest","ParticleSystem","randomValue","base","spread","random","randomVector3","rand3","addVectors","multiplyVectors","createParticle","particle","SPHERE","r","sqrt","vec3","cos","sin","direction","subVectors","speed","normalize","initialize","vertices","dynamic","sortParticles","scene","recycleIndices","push","startIndex","round","endIndex","j","destroy","remove"],"mappings":"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","file":"particles.3d2dec65.js","sourceRoot":"..","sourcesContent":["/**\n* @author Lee Stemkoski   http://www.adelphi.edu/~stemkoski/\n*/\n\n///////////////////////////////////////////////////////////////////////////////\n\n/////////////\n// SHADERS //\n/////////////\n\n// attribute: data that may be different for each particle (such as size and color);\n//      can only be used in vertex shader\n// varying: used to communicate data from vertex shader to fragment shader\n// uniform: data that is the same for each particle (such as texture)\n\nparticleVertexShader =\n    [\n        \"attribute vec3  customColor;\",\n        \"attribute float customOpacity;\",\n        \"attribute float customSize;\",\n        \"attribute float customAngle;\",\n        \"attribute float customVisible;\",  // float used as boolean (0 = false, 1 = true)\n        \"varying vec4  vColor;\",\n        \"varying float vAngle;\",\n        \"void main()\",\n        \"{\",\n        \"if ( customVisible > 0.5 )\", \t\t\t\t// true\n        \"vColor = vec4( customColor, customOpacity );\", //     set color associated to vertex; use later in fragment shader.\n        \"else\",\t\t\t\t\t\t\t// false\n        \"vColor = vec4(0.0, 0.0, 0.0, 0.0);\", \t\t//     make particle invisible.\n\n        \"vAngle = customAngle;\",\n\n        \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n        \"gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );\",     // scale particles as objects in 3D space\n        \"gl_Position = projectionMatrix * mvPosition;\",\n        \"}\"\n    ].join(\"\\n\");\n\nparticleFragmentShader =\n    [\n        \"uniform sampler2D texture;\",\n        \"varying vec4 vColor;\",\n        \"varying float vAngle;\",\n        \"void main()\",\n        \"{\",\n        \"gl_FragColor = vColor;\",\n\n        \"float c = cos(vAngle);\",\n        \"float s = sin(vAngle);\",\n        \"vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,\",\n        \"c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);\",  // rotate UV coordinates to rotate texture\n        \"vec4 rotatedTexture = texture2D( texture,  rotatedUV );\",\n        \"gl_FragColor = gl_FragColor * rotatedTexture;\",    // sets an otherwise white particle texture to desired color\n        \"}\"\n    ].join(\"\\n\");\n\n///////////////////////////////////////////////////////////////////////////////\n\n/////////////////\n// TWEEN CLASS //\n/////////////////\n\nfunction Tween(timeArray, valueArray) {\n    this.times = timeArray || [];\n    this.values = valueArray || [];\n}\n\nTween.prototype.lerp = function (t) {\n    var i = 0;\n    var n = this.times.length;\n    while (i < n && t > this.times[i])\n        i++;\n    if (i == 0) return this.values[0];\n    if (i == n) return this.values[n - 1];\n    var p = (t - this.times[i - 1]) / (this.times[i] - this.times[i - 1]);\n    if (this.values[0] instanceof THREE.Vector3)\n        return this.values[i - 1].clone().lerp(this.values[i], p);\n    else // its a float\n        return this.values[i - 1] + p * (this.values[i] - this.values[i - 1]);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n////////////////////\n// PARTICLE CLASS //\n////////////////////\n\nfunction Particle() {\n    this.position = new THREE.Vector3();\n    this.velocity = new THREE.Vector3(); // units per second\n    this.acceleration = new THREE.Vector3();\n\n    this.angle = 0;\n    this.angleVelocity = 0; // degrees per second\n    this.angleAcceleration = 0; // degrees per second, per second\n\n    this.size = 16.0;\n\n    this.color = new THREE.Color();\n    this.opacity = 1.0;\n\n    this.age = 0;\n    this.alive = 0; // use float instead of boolean for shader purposes\t\n}\n\nParticle.prototype.update = function (dt) {\n    this.position.add(this.velocity.clone().multiplyScalar(dt));\n    this.velocity.add(this.acceleration.clone().multiplyScalar(dt));\n\n    // convert from degrees to radians: 0.01745329251 = Math.PI/180\n    this.angle += this.angleVelocity * 0.01745329251 * dt;\n    this.angleVelocity += this.angleAcceleration * 0.01745329251 * dt;\n\n    this.age += dt;\n\n    // if the tween for a given attribute is nonempty,\n    //  then use it to update the attribute's value\n\n    if (this.sizeTween.times.length > 0)\n        this.size = this.sizeTween.lerp(this.age);\n\n    if (this.colorTween.times.length > 0) {\n        var colorHSL = this.colorTween.lerp(this.age);\n        this.color = new THREE.Color().setHSL(colorHSL.x, colorHSL.y, colorHSL.z);\n    }\n\n    if (this.opacityTween.times.length > 0)\n        this.opacity = this.opacityTween.lerp(this.age);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////\n// PARTICLE ENGINE CLASS //\n///////////////////////////\n\nvar Type = Object.freeze({ \"CUBE\": 1, \"SPHERE\": 2 });\n\nfunction ParticleEngine() {\n    /////////////////////////\n    // PARTICLE PROPERTIES //\n    /////////////////////////\n\n    this.positionStyle = Type.CUBE;\n    this.positionBase = new THREE.Vector3();\n    // cube shape data\n    this.positionSpread = new THREE.Vector3();\n    // sphere shape data\n    this.positionRadius = 0; // distance from base at which particles start\n\n    this.velocityStyle = Type.CUBE;\n    // cube movement data\n    this.velocityBase = new THREE.Vector3();\n    this.velocitySpread = new THREE.Vector3();\n    // sphere movement data\n    //   direction vector calculated using initial position\n    this.speedBase = 0;\n    this.speedSpread = 0;\n\n    this.accelerationBase = new THREE.Vector3();\n    this.accelerationSpread = new THREE.Vector3();\n\n    this.angleBase = 0;\n    this.angleSpread = 0;\n    this.angleVelocityBase = 0;\n    this.angleVelocitySpread = 0;\n    this.angleAccelerationBase = 0;\n    this.angleAccelerationSpread = 0;\n\n    this.sizeBase = 0.0;\n    this.sizeSpread = 0.0;\n    this.sizeTween = new Tween();\n\n    // store colors in HSL format in a THREE.Vector3 object\n    // http://en.wikipedia.org/wiki/HSL_and_HSV\n    this.colorBase = new THREE.Vector3(0.0, 1.0, 0.5);\n    this.colorSpread = new THREE.Vector3(0.0, 0.0, 0.0);\n    this.colorTween = new Tween();\n\n    this.opacityBase = 1.0;\n    this.opacitySpread = 0.0;\n    this.opacityTween = new Tween();\n\n    this.blendStyle = THREE.NormalBlending; // false;\n\n    this.particleArray = [];\n    this.particlesPerSecond = 100;\n    this.particleDeathAge = 1.0;\n\n    ////////////////////////\n    // EMITTER PROPERTIES //\n    ////////////////////////\n\n    this.emitterAge = 0.0;\n    this.emitterAlive = true;\n    this.emitterDeathAge = 60; // time (seconds) at which to stop creating particles.\n\n    // How many particles could be active at any time?\n    this.particleCount = this.particlesPerSecond * Math.min(this.particleDeathAge, this.emitterDeathAge);\n\n    //////////////\n    // THREE.JS //\n    //////////////\n\n    this.particleGeometry = new THREE.Geometry();\n    this.particleTexture = null;\n    this.particleMaterial = new THREE.ShaderMaterial(\n        {\n            uniforms:\n            {\n                texture: { type: \"t\", value: this.particleTexture },\n            },\n            attributes:\n            {\n                customVisible: { type: 'f', value: [] },\n                customAngle: { type: 'f', value: [] },\n                customSize: { type: 'f', value: [] },\n                customColor: { type: 'c', value: [] },\n                customOpacity: { type: 'f', value: [] }\n            },\n            vertexShader: particleVertexShader,\n            fragmentShader: particleFragmentShader,\n            transparent: true, // alphaTest: 0.5,  // if having transparency issues, try including: alphaTest: 0.5, \n            blending: THREE.NormalBlending, depthTest: true,\n\n        });\n    this.particleMesh = new THREE.Mesh();\n}\n\nParticleEngine.prototype.setValues = function (parameters) {\n    if (parameters === undefined) return;\n\n    // clear any previous tweens that might exist\n    this.sizeTween = new Tween();\n    this.colorTween = new Tween();\n    this.opacityTween = new Tween();\n\n    for (var key in parameters)\n        this[key] = parameters[key];\n\n    // attach tweens to particles\n    Particle.prototype.sizeTween = this.sizeTween;\n    Particle.prototype.colorTween = this.colorTween;\n    Particle.prototype.opacityTween = this.opacityTween;\n\n    // calculate/set derived particle engine values\n    this.particleArray = [];\n    this.emitterAge = 0.0;\n    this.emitterAlive = true;\n    this.particleCount = this.particlesPerSecond * Math.min(this.particleDeathAge, this.emitterDeathAge);\n\n    this.particleGeometry = new THREE.Geometry();\n    this.particleMaterial = new THREE.ShaderMaterial(\n        {\n            uniforms:\n            {\n                texture: { type: \"t\", value: this.particleTexture },\n            },\n            attributes:\n            {\n                customVisible: { type: 'f', value: [] },\n                customAngle: { type: 'f', value: [] },\n                customSize: { type: 'f', value: [] },\n                customColor: { type: 'c', value: [] },\n                customOpacity: { type: 'f', value: [] }\n            },\n            vertexShader: particleVertexShader,\n            fragmentShader: particleFragmentShader,\n            transparent: true, alphaTest: 0.5, // if having transparency issues, try including: alphaTest: 0.5, \n            blending: THREE.NormalBlending, depthTest: true\n        });\n    this.particleMesh = new THREE.ParticleSystem();\n}\n\n// helper functions for randomization\nParticleEngine.prototype.randomValue = function (base, spread) {\n    return base + spread * (Math.random() - 0.5);\n}\nParticleEngine.prototype.randomVector3 = function (base, spread) {\n    var rand3 = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n    return new THREE.Vector3().addVectors(base, new THREE.Vector3().multiplyVectors(spread, rand3));\n}\n\n\nParticleEngine.prototype.createParticle = function () {\n    var particle = new Particle();\n\n    if (this.positionStyle == Type.CUBE)\n        particle.position = this.randomVector3(this.positionBase, this.positionSpread);\n    if (this.positionStyle == Type.SPHERE) {\n        var z = 2 * Math.random() - 1;\n        var t = 6.2832 * Math.random();\n        var r = Math.sqrt(1 - z * z);\n        var vec3 = new THREE.Vector3(r * Math.cos(t), r * Math.sin(t), z);\n        particle.position = new THREE.Vector3().addVectors(this.positionBase, vec3.multiplyScalar(this.positionRadius));\n    }\n\n    if (this.velocityStyle == Type.CUBE) {\n        particle.velocity = this.randomVector3(this.velocityBase, this.velocitySpread);\n    }\n    if (this.velocityStyle == Type.SPHERE) {\n        var direction = new THREE.Vector3().subVectors(particle.position, this.positionBase);\n        var speed = this.randomValue(this.speedBase, this.speedSpread);\n        particle.velocity = direction.normalize().multiplyScalar(speed);\n    }\n\n    particle.acceleration = this.randomVector3(this.accelerationBase, this.accelerationSpread);\n\n    particle.angle = this.randomValue(this.angleBase, this.angleSpread);\n    particle.angleVelocity = this.randomValue(this.angleVelocityBase, this.angleVelocitySpread);\n    particle.angleAcceleration = this.randomValue(this.angleAccelerationBase, this.angleAccelerationSpread);\n\n    particle.size = this.randomValue(this.sizeBase, this.sizeSpread);\n\n    var color = this.randomVector3(this.colorBase, this.colorSpread);\n    particle.color = new THREE.Color().setHSL(color.x, color.y, color.z);\n\n    particle.opacity = this.randomValue(this.opacityBase, this.opacitySpread);\n\n    particle.age = 0;\n    particle.alive = 0; // particles initialize as inactive\n\n    return particle;\n}\n\nParticleEngine.prototype.initialize = function () {\n    // link particle data with geometry/material data\n    for (var i = 0; i < this.particleCount; i++) {\n        // remove duplicate code somehow, here and in update function below.\n        this.particleArray[i] = this.createParticle();\n        this.particleGeometry.vertices[i] = this.particleArray[i].position;\n        this.particleMaterial.attributes.customVisible.value[i] = this.particleArray[i].alive;\n        this.particleMaterial.attributes.customColor.value[i] = this.particleArray[i].color;\n        this.particleMaterial.attributes.customOpacity.value[i] = this.particleArray[i].opacity;\n        this.particleMaterial.attributes.customSize.value[i] = this.particleArray[i].size;\n        this.particleMaterial.attributes.customAngle.value[i] = this.particleArray[i].angle;\n    }\n\n    this.particleMaterial.blending = this.blendStyle;\n    if (this.blendStyle != THREE.NormalBlending)\n        this.particleMaterial.depthTest = false;\n\n    this.particleMesh = new THREE.ParticleSystem(this.particleGeometry, this.particleMaterial);\n    this.particleMesh.dynamic = true;\n    this.particleMesh.sortParticles = true;\n    scene.add(this.particleMesh);\n}\n\nParticleEngine.prototype.update = function (dt) {\n    var recycleIndices = [];\n\n    // update particle data\n    for (var i = 0; i < this.particleCount; i++) {\n        if (this.particleArray[i].alive) {\n            this.particleArray[i].update(dt);\n\n            // check if particle should expire\n            // could also use: death by size<0 or alpha<0.\n            if (this.particleArray[i].age > this.particleDeathAge) {\n                this.particleArray[i].alive = 0.0;\n                recycleIndices.push(i);\n            }\n            // update particle properties in shader\n            this.particleMaterial.attributes.customVisible.value[i] = this.particleArray[i].alive;\n            this.particleMaterial.attributes.customColor.value[i] = this.particleArray[i].color;\n            this.particleMaterial.attributes.customOpacity.value[i] = this.particleArray[i].opacity;\n            this.particleMaterial.attributes.customSize.value[i] = this.particleArray[i].size;\n            this.particleMaterial.attributes.customAngle.value[i] = this.particleArray[i].angle;\n        }\n    }\n\n    // check if particle emitter is still running\n    if (!this.emitterAlive) return;\n\n    // if no particles have died yet, then there are still particles to activate\n    if (this.emitterAge < this.particleDeathAge) {\n        // determine indices of particles to activate\n        var startIndex = Math.round(this.particlesPerSecond * (this.emitterAge + 0));\n        var endIndex = Math.round(this.particlesPerSecond * (this.emitterAge + dt));\n        if (endIndex > this.particleCount)\n            endIndex = this.particleCount;\n\n        for (var i = startIndex; i < endIndex; i++)\n            this.particleArray[i].alive = 1.0;\n    }\n\n    // if any particles have died while the emitter is still running, we imediately recycle them\n    for (var j = 0; j < recycleIndices.length; j++) {\n        var i = recycleIndices[j];\n        this.particleArray[i] = this.createParticle();\n        this.particleArray[i].alive = 1.0; // activate right away\n        this.particleGeometry.vertices[i] = this.particleArray[i].position;\n    }\n\n    // stop emitter?\n    this.emitterAge += dt;\n    if (this.emitterAge > this.emitterDeathAge) this.emitterAlive = false;\n}\n\nParticleEngine.prototype.destroy = function () {\n    scene.remove(this.particleMesh);\n}\n///////////////////////////////////////////////////////////////////////////////"]}